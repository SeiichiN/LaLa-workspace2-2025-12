<style>
.my-text {
background-color: #f5f5f5;
padding: 10px;
margin-left: 30%;
}
</style>

<div class="my-text">
java21で、次のような日付のチェックプログラムを書きました。

```java
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.time.format.ResolverStyle;
import java.util.Date;
import java.util.Scanner;

public class CheckDate {

	public static void main(String[] args) {
		System.out.println("誕生日を入力してください (yyyy/MM/dd)");
		String date1 = new Scanner(System.in).nextLine();
		if (isValidDateNew(date1)) {
			System.out.println("正しい日付です");
		} else {
			System.out.println("日付が正しくありません");
		}

	}

	public static boolean isValidDate(String dateTxt) {
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd");
		sdf.setLenient(false);
		try {
			Date d = sdf.parse(dateTxt);
			System.out.println(d);
		} catch (ParseException e) {
			return false;
		}
		return true;
	}
	
	public static boolean isValidDateNew(String dateTxt) {
		DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd")
				.withResolverStyle(ResolverStyle.STRICT);
		try {
			LocalDate.parse(dateTxt, dtf);
		} catch(DateTimeParseException e) {
			return false;
		}
		return true;
	}
}
```
何か、問題はありませんか？
</div>

---

プログラムは大体機能していますが、以下の点に注意が必要です。

1. `Date` クラスは、Java8以降では非推奨です。`LocalDate` クラスを使用することをお勧めします。

2. `try-catch` 文で `ParseException` をキャッチしていますが、`SimpleDateFormat` は `ParseException` をスローしない場合があります。代わりに、`SimpleDateFormat` の `parse()` メソッドが `null` を返します。したがって、`isValidDate` メソッドで `Date` を `null` に設定する可能性があります。

3. `isValidDateNew` メソッドで `LocalDate.parse()` を使用していますが、`LocalDate.parse()` は `DateTimeParseException` をスローします。ただし、この例では `DateTimeParseException` をキャッチして `false` を返していますが、より明確なエラーメッセージを表示することをお勧めします。

修正後のプログラムは次のようになります。

```java
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.Scanner;

public class CheckDate {

	public static void main(String[] args) {
		System.out.println("誕生日を入力してください (yyyy/MM/dd)");
		String date1 = new Scanner(System.in).nextLine();
		if (isValidDateNew(date1)) {
			System.out.println("正しい日付です");
		} else {
			System.out.println("日付が正しくありません");
		}

	}

	public static boolean isValidDateNew(String dateTxt) {
		DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd")
				.withResolverStyle(ResolverStyle.STRICT);
		try {
			LocalDate.parse(dateTxt, dtf);
			return true;
		} catch(DateTimeParseException e) {
			String message = String.format("Invalid date: %s", dateTxt);
			System.out.println(message);
			return false;
		}
	}
}
```
---

<div class="my-text">
java.util.Dateクラスを使った日付のチェックプログラムを修正しました。どうでしょうか？

```
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.time.format.ResolverStyle;
import java.util.Date;
import java.util.Scanner;

public class CheckDate {
	public static final Scanner SC = new Scanner(System.in);

	public static void main(String[] args) {
		System.out.println("誕生日を入力してください (yyyy/MM/dd)");
		String date1 = SC.nextLine();
		if (isValidDate(date1)) {
			System.out.println("正しい日付です");
		} else {
			System.out.println("日付が正しくありません");
		}

	}

	public static boolean isValidDate(String dateTxt) {
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd");
		sdf.setLenient(false);
		try {
			Date d = sdf.parse(dateTxt);
			if (d == null) return false;
			if (d.after(new Date())) {
				System.out.println("未来の日付です");
				return false;
			}
		} catch (ParseException e) {
			System.out.println(e.getMessage());
			return false;
		}
		return true;
	}
}
```

</div>

---

修正後のプログラムは、`java.util.Date` クラスを使用して、日付のチェックを行なっています。プログラムは、基本的に動作していますが、以下の点に注意が必要です。

1. `java.util.Date` クラスは、Java8以降では非推奨です。`LocalDate` クラスを使用することをお勧めします。

2. `try-catch` 文で `ParseException` をキャッチしていますが、`SimpleDateFormat` は `ParseException` をスローしない場合があります。代わりに、`SimpleDateFormat` の `parse()` メソッドが `null` を返します。したがって、`isValidDate` メソッドで `Date` を `null` に設定する可能性があります。

3. `isValidDate` メソッドで `Date` を `null` に設定する可能性があるため、プログラムの動作が不安定です。代わりに、`SimpleDateFormat` の `parse()` メソッドが `null` を返す場合に、`false` を返してください。

修正後のプログラムは次のようになります。

```java
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

public class CheckDate {

	public static final Scanner SC = new Scanner(System.in);

	public static void main(String[] args) {
		System.out.println("誕生日を入力してください (yyyy/MM/dd)");
		String date1 = SC.nextLine();
		if (isValidDate(date1)) {
			System.out.println("正しい日付です");
		} else {
			System.out.println("日付が正しくありません");
		}

	}

	public static boolean isValidDate(String dateTxt) {
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd");
		sdf.setLenient(false);
		try {
			Date d = sdf.parse(dateTxt);
			if (d == null) return false;
			if (d.after(new Date())) {
				System.out.println("未来の日付です");
				return false;
			}
		} catch (Exception e) {
			System.out.println(e.getMessage());
			return false;
		}
		return true;
	}
}
```

